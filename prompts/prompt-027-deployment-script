Create a PowerShell deployment script called deploy.ps1 in the deploy-infra folder that fully automates the infrastructure deployment.

The script should accept parameters for the resource group name (required), Azure region (required), a base name for resources (optional, defaults to "expensemgmt"), a switch to deploy GenAI resources like Azure OpenAI and AI Search, and a switch to skip database setup for redeployments.

The deployment process should:

1. Check that Azure CLI is installed and the user is logged in
2. Automatically retrieve the current user's Azure AD credentials (Object ID and User Principal Name)
3. Create the resource group if needed
4. Deploy all infrastructure using the Bicep templates
5. Wait for SQL Server to become ready before proceeding
6. Add the user's current IP address to the SQL Server firewall
7. Import the database schema using sqlcmd with Entra ID authentication
8. Create a database user for the managed identity and grant it read, write, and execute permissions
9. Create the stored procedures required by the application
10. Configure the App Service with ALL required settings (see critical settings below)
11. If GenAI resources were deployed, configure the OpenAI and Search endpoints
12. Save a deployment context file (.deployment-context.json) at the repository root

Critical App Service settings that MUST be configured during infrastructure deployment:

- AZURE_CLIENT_ID: The managed identity client ID (required for DefaultAzureCredential)
- ConnectionStrings__DefaultConnection: The full SQL connection string with Managed Identity authentication
- APPLICATIONINSIGHTS_CONNECTION_STRING: For Application Insights telemetry

The SQL connection string format MUST be:
Server=tcp:{sqlServerFqdn},1433;Initial Catalog=Northwind;Encrypt=True;TrustServerCertificate=False;Connection Timeout=30;Authentication=Active Directory Managed Identity;User Id={managedIdentityClientId};

Without these settings, the application will fail to connect to the database even if the managed identity has correct permissions.

The deployment context file enables seamless handoff to the application deployment script (deploy-app/deploy.ps1). Include the resource group, web app name, SQL server FQDN, and managed identity client ID in this context file.

The script should provide clear progress indicators, handle errors gracefully, and display a summary of deployed resources at the end.

Critical implementation details:

1. When calling sqlcmd from PowerShell, quote the authentication argument to prevent parsing errors:
   sqlcmd -S $serverFqdn -d "Northwind" "--authentication-method=ActiveDirectoryDefault" -i $schemaFile

2. Never pipe SQL directly to sqlcmd as this causes go-sqlcmd to crash with nil pointer errors. Always write SQL to a temporary file first:
   $tempFile = [System.IO.Path]::GetTempFileName() + ".sql"
   $sql | Out-File -FilePath $tempFile -Encoding UTF8
   sqlcmd -S $server -d $database -i $tempFile
   Remove-Item -Path $tempFile -Force

3. Always use fresh resource group names for deployments. Reusing resource groups with partially deployed resources can cause ARM caching issues, particularly with Log Analytics Workspace references.

4. The script should warn users if they're running PowerShell 5.1 and recommend upgrading to PowerShell 7+.

5. VS Code's integrated terminal may use a cached PATH. If sqlcmd errors occur, recommend running from a standalone PowerShell terminal or restarting VS Code.

6. When passing parameters to Azure CLI commands like `az deployment group create`, you cannot pass a PowerShell hashtable directly. Use inline key=value pairs instead:

   Correct approach:
   ```powershell
   az deployment group create `
       --resource-group $ResourceGroup `
       --template-file "./main.bicep" `
       --parameters location=$Location baseName=$BaseName deployGenAI=$($DeployGenAI.ToString().ToLower())
   ```

   Wrong approach (causes "Unable to parse parameter: System.Collections.Hashtable" error):
   ```powershell
   $params = @{ location = $Location; baseName = $BaseName }
   az deployment group create --parameters $params  # This fails!
   ```

7. When capturing Azure CLI output for JSON parsing, redirect stderr to null (`2>$null`) rather than merging it with stdout (`2>&1`). Bicep warnings go to stderr and will corrupt the JSON output if mixed:

   Correct approach:
   ```powershell
   $output = az deployment group create --output json 2>$null
   $deployment = $output | ConvertFrom-Json
   ```

   Wrong approach (causes "Conversion from JSON failed" when Bicep has warnings):
   ```powershell
   $output = az deployment group create --output json 2>&1
   $deployment = $output | ConvertFrom-Json  # Fails if warnings present!
   ```

8. **Handle Azure Policy timing issues**: When deploying to subscriptions with governance policies, Azure may automatically create policy-related deployments (like diagnostic settings) that can fail transiently while retrying in the background. The deployment command may return a non-zero exit code even though YOUR infrastructure deployed successfully.

   Implement resilient error handling:
   ```powershell
   $deployOutput = az deployment group create --resource-group $ResourceGroup --template-file "./main.bicep" --parameters ... --output json 2>$null
   
   if ($LASTEXITCODE -ne 0 -or [string]::IsNullOrWhiteSpace($deployOutput)) {
       Write-Warning "Deployment command returned an error. This can happen when Azure policies are being applied."
       Write-Host "Waiting for policy deployments to settle..." -ForegroundColor Yellow
       Start-Sleep -Seconds 15
       
       # Find the main Bicep deployment (not policy-related)
       $allDeployments = az deployment group list --resource-group $ResourceGroup --output json 2>$null | ConvertFrom-Json
       $mainDeployment = $allDeployments | Where-Object { 
           $_.name -notlike "PolicyDeployment_*" -and 
           $_.name -notlike "Failure-Anomalies-*" -and
           $_.name -notlike "*-diagnostics-*" -and
           $_.properties.provisioningState -eq "Succeeded"
       } | Sort-Object -Property @{Expression={[datetime]$_.properties.timestamp}; Descending=$true} | Select-Object -First 1
       
       if ($mainDeployment) {
           Write-Host "âœ“ Found successful deployment: $($mainDeployment.name)" -ForegroundColor Green
           $deployOutput = az deployment group show --resource-group $ResourceGroup --name $mainDeployment.name --output json 2>$null
       } else {
           Write-Error "Infrastructure deployment failed. Check Azure portal for details."
           exit 1
       }
   }
   ```

   This handles race conditions where policy deployments fail but automatically retry while your main infrastructure deployment succeeds. The script waits briefly and then searches for the successful main deployment by filtering out policy-related deployment names.

See also: prompt-016-sqlcmd-for-sql for detailed sqlcmd usage, prompt-028-github-actions-cicd for CI/CD considerations.

Prerequisites: Azure CLI, go-sqlcmd (install with winget install sqlcmd), and PowerShell 7+ recommended.
